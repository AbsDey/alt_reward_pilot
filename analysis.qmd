---
title: "Alternating Reward — Stroop variant (ARS) Pilot"
format: 
  html:
    page-layout: full
    theme: default
    font-size: 18px
    toc: true
output-file: index.html
editor: visual
---

Created by Abs Dey 06-04-2025

```{r}
#| label: setup
#| include: false

rm(list=ls())
cat('\14')

library(tidyverse)
library(gt)
library(stringr)
library(lme4)
library(lmerTest)
library(psychReport)
library(ggplot2)

data_path <- "C:/Users/deyne/Documents/WashU_Job/MURI_Position/Stroop Reward Task/data/"
# knitr::opts_knit$set(root.dir = data_path)
# # setwd(data_path) 
```

<br>

## Basic Design

<br>

![](design.svg){.lightbox}

<br>

Participants go through learning, practice, and baseline blocks of Stroop stimuli. Following this, they go through two types of Stroop blocks:

1.  Rewarded blocks — A specific color item is rewarded

2.  Unrewarded blocks — No colors/trials are rewarded.

Participants are given 4 cycles of alternating sequences of 1. and 2. above. Reward blocks always start at the beginning of the cycle.

------------------------------------------------------------------------

<br>

## Preliminaries

```{r}
#| echo: false
#| label: read-data

df <- read.csv(paste(data_path, "data_cleaned.csv", sep=""))

# variables used in multiple chunks
unique_ids <- unique(df$ProlificID)

short_id_len <- 7 # length of the short ID format
df$ShortID <- substr(df$ProlificID, 1, short_id_len)
unique_sids <- unique(df$ShortID)
cat("Added short IDs to data...")


if(length(unique_ids) == length(unique_sids)){
  msg = paste("Long and short format IDs match in number(",
              length(unique_sids), ").\n\n", sep="")
} else{
  msg = paste("**WARNING**: ID formats do not match in number (long = ",
  length(unique_ids), "; short = ", length(unique_sids),
  ").\nConsider increasing the length of the short ID format if two long IDs are similar.\n", sep="")
}

cat(msg)
```

:::: {.callout-note collapse="true" appearance="minimal"}
### Minimal QC checks

::: panel-tabset
#### Checking Overall Trial Counts

```{r}
#| echo: false
#| label: trial_count_check
#| results: asis

expected_count <- 1056 # minimum count, multiple learning tries will increase this count
experiment_expected_count <- 1008 # maximum number of trials combining baseline and alternating blocks

trial_counts_df <- data.frame(
  shortid = character(), 
  count = numeric(),
  experiment_count = numeric(),
  check = logical()
  )
num_checks <- 0
for(p in unique_sids){
  temp_df <- df[df$ShortID==p, ]
  trial_count <- length(temp_df$ProlificID) # using column that exists in the source data to count trials
  experiment_count <- as.numeric(temp_df |>
                                   filter(BlockType != "Learning" & BlockType!= "Practice") |>
                                   tally())
  if(trial_count>=expected_count & experiment_count == experiment_expected_count){
    trial_counts_df <- rbind(trial_counts_df, data.frame(prolificid = p, count = trial_count, check = FALSE))
  }
  else{
    trial_counts_df <- rbind(trial_counts_df, data.frame(prolificid = p, count = trial_count, check = TRUE))
    num_checks <- num_checks+ 1
  }
}
# cat('<div style="font-size: 24px;">') 
cat(num_checks, "checks needed.")
# cat('</div>')
DT::datatable(trial_counts_df)

```

#### Inspecting Trial Structure per Participant

```{r}
#| echo: false
#| label: adding-additional-columns


df$data_exists <- !is.na(df$Stimulus.RT) & !is.na(df$Stimulus.RESP)
df$rewarded_this_cycle <- ifelse(df$rewardedColor==df$Color, "Yes", "No")
df$rewarded_this_cycle <- as.factor(df$rewarded_this_cycle)

# important to add this PRIOR to filtering
df$joint_trial_num <- NA

for (id in unique_ids) {
  idx <- which(df$ProlificID == id)

  max_b <- max(df$btrial_num[idx], na.rm = TRUE)
  
  # baseline trials
  idx_base <- idx[df$BlockType[idx] == "StroopBaseline" & !is.na(df$btrial_num[idx])]
  df$joint_trial_num[idx_base] <- df$btrial_num[idx_base]
  
  # alternating trials
  idx_alt <- idx[df$BlockType[idx] != "StroopBaseline" & !is.na(df$abtrial_num[idx])]
  df$joint_trial_num[idx_alt] <- df$abtrial_num[idx_alt] + max_b
}

df$rtc_trialnum <- NA
for (id in unique_ids){
  idx <- which(df$ProlificID == id & df$rewarded_this_cycle=="Yes")
  counter = 0
  for (rtc_trial in idx){
    counter = counter + 1
    df$rtc_trialnum[rtc_trial] = counter
  }
}

df$rewarded_distractor_identity <- as.factor(
  ifelse(df$Word==df$rewardedColor,"Yes", "No")
  )

```

```{r}
#| echo: false
#| warning: false
#| label: trial_structure_inspection
#| fig-width: 20
#| fig-height: 24
#| dpi: 150
#| fig-format: "svg"
#| fig-retina: 2

# colors for block types
fill_colors <- c(
  "StroopBaseline" = "white", 
  "RewardList" = "paleturquoise1",     
  "NoRewardList" = "grey"   
)

# colors for congruency
congruency_colors <- c(
  "Congruent" = "lightgreen",
  "Incongruent" = "lightcoral"
)


# alpha for reward trial type
reward_alpha <- c(
  "0" = 0.2,
  "1" = 1
) 

pad_line <- 0.15

shade_list <- list()
for (id in unique(df$ShortID)) {
  temp_df <- df[df$ShortID == id & df$data_exists, ]
  block_types <- temp_df$BlockType
  joint_nums <- temp_df$joint_trial_num
  n <- nrow(temp_df)
  region_starts <- c(1, which(block_types[-1] != block_types[-n]) + 1)
  region_ends <- c(region_starts[-1] - 1, n)
  shade_df <- data.frame(
    ShortID = id,
    xmin = joint_nums[region_starts],
    xmax = joint_nums[region_ends],
    BlockType = block_types[region_starts]
  )
  shade_df <- shade_df[shade_df$BlockType %in% c("StroopBaseline", "RewardList", "NoRewardList"), ]
  shade_list[[id]] <- shade_df
}
all_shade_df <- do.call(rbind, shade_list)

vline_df <- aggregate(btrial_num ~ ShortID, data = df, FUN = function(x) max(x, na.rm = TRUE))
vline_df$x_break <- vline_df$btrial_num + 0.5

p <- ggplot(df[df$data_exists, ], aes(x = joint_trial_num)) +
  # shading
  geom_rect(
    data = all_shade_df,
    inherit.aes = FALSE,
    aes(xmin = xmin - 0.5, xmax = xmax + 0.5, ymin = -Inf, ymax = Inf, fill = BlockType),
    alpha = 0.2
  ) +
  scale_fill_manual(values = fill_colors) +
  geom_linerange(aes(ymin = (Stimulus.RT/1000)-pad_line, ymax = (Stimulus.RT/1000)+pad_line,
                     color = Congruency, alpha = rewarded_this_cycle), size = 0.5) +
  scale_color_manual(values = congruency_colors) +
  # vertical lines for block transitions
  geom_vline(
    data = vline_df,
    aes(xintercept = x_break),
    color = "black", size = .75, linetype = 2, inherit.aes = FALSE
  ) +
  labs(
    title = "Data available (experimental blocks) by participant",
    x = "Trial Number",
    y = "RT (seconds)"
  ) +
  scale_alpha_manual(values = reward_alpha, na.value = 0.5) +
  scale_x_continuous(
    limits = c(1, max(df$joint_trial_num, na.rm = T)+1), # adding extra trial so shading can work
    breaks = seq(72, max(df$joint_trial_num, na.rm = T), by = 72), # 72 is 1/2 block length
    expand = c(0.01,10)) +
  scale_y_continuous(limits = c(0, 3)) +
  facet_wrap(~ ShortID, scales = "free_x", ncol = 2) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.y = element_blank()
  )

ggsave(
  filename = "participant_trial_structure.svg", 
  plot = p,
  device = "svg",
  width = 20,  
  height = 24,  
  dpi = 300,   
  bg = "white" 
)

rm(p) # clearing space
```

![Note. For each participant, we plot the RT for every trial during the experimenal phase of the study. That is, all trials excluding those in the Learning and Practice blocks are included. For a given trial, participants' RT is indicated by the position of the midpoint of a dash. Green dashes indicate congruent trials. Red dashes indicate incongruent trials. The section with white background at the start of each trial series is a baseline block. The turquoise background is a reward block, and the gray background is a no reward block.](participant_trial_structure.svg){.lightbox}
:::
::::

<br>

## Filters

**Note:** Removed participant " 6837a5" due to them pressing any button as fast as possible (\<100 ms) during non-reward contexts (see QC trial structure checks).

```{r}
#| label: Filters

# RT cutoffs based on prior work
# removing  " 6837a5" (note the leading space); 
#   RTs < 100 during non-rewarded blocks; speeding past those blocks
data <- df |>
  filter(Stimulus.RT>200 & Stimulus.RT<3000 & ShortID != " 6837a5")

# reset unique_ids and unique_sids for summaries
unique_ids <- unique(data$ProlificID)
unique_sids <- unique(data$ShortID)
```

------------------------------------------------------------------------

<br>

## Alternating Blocks

Here we're inspecting descriptives for only the alternating sequence of reward and no reward blocks. That is, we don't look at Learning, Practice, or Baseline blocks.

<br>

### RT Density Plots

```{r}
#| code-fold: true
#| warning: false
#| label: RT-distributions-alternating-blocks
#| fig-width: 18
#| fig-height: 18
#| dpi: 300
#| fig-format: "svg"
#| fig-retina: 2

cutoff_rts <- data |>
  filter(Stimulus.ACC == 1) |>
  group_by(ShortID) |>
  summarise(
    cutoff_cong = round(unique(CutoffRTcong.Session.)),
    cutoff_incong = round(unique(CutoffRTincong.Session.))
  ) |>
  pivot_longer(
    cols = c(cutoff_cong, cutoff_incong),
    names_to = "cutoff_type",
    values_to = "rt_value"
  )

p <- data |>
  filter(Stimulus.ACC == 1 & !is.na(AlternatingBlocks)) |>
  ggplot(aes(x = Stimulus.RT)) + 
  geom_histogram(aes(y = ..density..), colour = "black", fill = "white", bins = 50) +
  geom_density(alpha = .2, fill = "grey40") +
  geom_vline(data = cutoff_rts, 
             aes(xintercept = rt_value, color = cutoff_type), 
             linetype = "dashed", linewidth = 0.8) +
  scale_color_manual(
    values = c("cutoff_cong" = "lightgreen", "cutoff_incong" = "lightcoral"),
    labels = c("Congruent Cutoff", "Incongruent Cutoff")
  ) +
  facet_wrap(~ ShortID, scales = "free_y", ncol=3) +
  scale_x_continuous(
    limits = c(150, 3000),
    # expand = c(0.02, 0.02),
    breaks = seq(300, 2800, by = 500)
  ) +
  labs(
    title = "RT by Participant",
    x = "RT (ms)",
    y = "Density"
  ) +
  theme_minimal() +
  theme(
    legend.position = "None",
    strip.text = element_text(size = 12),
    axis.text = element_text(size = 12)
  )

ggsave(
  filename = "participant_rt_dist.svg", 
  plot = p,
  device = "svg",
  width = 18,  
  height = 18,  
  dpi = 300,   
  bg = "white" 
)

rm(p) # clearing space
```

![Note. Only accurate RTs are shown here. Green dashed lines indicate a participant's cutoff RT for congruent trials. Red dashed lines indicate their cutoff RT for incongruent trials. Cutoffs were based on their performance during a baseline block and were set to their median RT for a congruent/incongruent trial type.](participant_rt_dist.svg){.lightbox}

<br>

### Trial Rewarded x Congruency (collapsed blocks): RT

```{r}
#| results: asis
#| echo: false
#| label: overall-reward-trial-means-rt

ab_rt_summary <- data |>
  filter(!is.na(AlternatingBlocks) & Stimulus.ACC == 1) |>
  droplevels() |>
  group_by(ShortID, RewardTrial, Congruency) |>
  summarise(
    mean_rt = mean(Stimulus.RT, na.rm = TRUE),
    sd_rt = sd(Stimulus.RT, na.rm = TRUE),
    n = n(), 
    .groups = "drop"
  )

cat("\n\n#### Overall\n\n")

print(
  ab_rt_summary |>
    group_by(RewardTrial, Congruency) |>
    summarise(
      means = round(mean(mean_rt, na.rm = TRUE)),
      sd = sd(mean_rt, na.rm = TRUE),
      n = n(),
      .groups = "drop"
      ) |>
    rename(
      "Rewarded Trial" = RewardTrial,
      "Mean RT (ms)" = means,
      "SD" = sd,
      "N" = n
    ) |>
    knitr::kable(
      format = "markdown",
      digits = 0
      ) |>
    kableExtra::kable_styling(full_width = FALSE, position = "left")
)

```

::: {.callout-note collapse="true" appearance="minimal"}
#### Participant-specific averages

```{r}
#| echo: false
#| results: asis
#| label: participant-reward-trial-means-rt

for (id in unique_sids) {
  cat("<br>")
  cat(id)
  print(
    ab_rt_summary |>
      filter(ShortID == id) |>
      select(-ShortID) |>
      rename(
      "Rewarded Trial" = RewardTrial,
      "Mean RT (ms)" = mean_rt,
      "SD" = sd_rt,
      "N" = n
    ) |>
      knitr::kable(
        format = "markdown",
        digits = 0
      ) |>
      kableExtra::kable_styling(full_width = FALSE, position = "left")
  )

  
}


```
:::

<br>

### Trial Rewarded (collapsed blocks) x Congruency: Errors

```{r}
#| echo: false
#| results: asis
#| label: overall-reward-trial-means-err

ab_err_summary <- data |>
  filter(!is.na(AlternatingBlocks)) |>
  droplevels() |>
  group_by(ShortID, RewardTrial, Congruency) |>
  summarise(
    mean_err = mean((1-Stimulus.ACC), na.rm = TRUE), # 1 - acc for err
    sd_err = sd((1-Stimulus.ACC), na.rm = TRUE),
    n = n(), 
    .groups = "drop"
  )

cat("\n\n#### Overall\n\n")

print(
  ab_err_summary |>
    group_by(RewardTrial, Congruency) |>
    summarise(
      means = round(mean(mean_err, na.rm = TRUE), 3),
      sd = sd(mean_err, na.rm = TRUE),
      n = n(),
      .groups = "drop"
      ) |>
    rename(
      "Rewarded Trial" = RewardTrial,
      "Mean Error" = means,
      "SD" = sd,
      "N" = n
    ) |>
    knitr::kable(
      format = "markdown",
      digits = 3
      ) |>
    kableExtra::kable_styling(full_width = FALSE, position = "left")
)

```

::: {.callout-note collapse="true" appearance="minimal"}
#### Participant-specific averages

```{r}
#| echo: false
#| results: asis
#| label: participant-reward-trial-means-err

for (id in unique_sids) {
  
  cat("<br>") 
  cat(id)
  print(
    ab_err_summary |>
      filter(ShortID == id) |>
      select(-ShortID) |>
      rename(
        "Rewarded Trial" = RewardTrial,
        "Mean Error" = mean_err,
        "SD" = sd_err,
        "N" = n
        ) |>
      knitr::kable(
        format = "markdown",
        digits = 3
      ) |>
      kableExtra::kable_styling(full_width = FALSE, position = "left")
    
  )


}

```
:::

<br>

### Color Rewarded (across cycle) x Reward Block x Congruency: RT

```{r}
#| results: asis
#| echo: false
#| warning: false
#| fig-width: 9
#| fig-height: 6
#| dpi: 300
#| fig-format: "svg"
#| fig-retina: 2
#| label: overall-color-reward-means

cycle_rt_summary <- data |>
  filter(!is.na(AlternatingBlocks) & Stimulus.ACC == 1) |>
  droplevels() |>
  group_by(ShortID, BlockType, rewarded_this_cycle, Congruency) |>
  summarise(
    mean_rt = round(mean(Stimulus.RT, na.rm = TRUE)),
    sd_rt = round(sd(Stimulus.RT, na.rm = TRUE)),
    n = n(), 
    .groups = "drop"
  ) |>
  mutate(BlockType = factor(BlockType, 
                           levels = c("RewardList", "NoRewardList"),
                           labels = c("Reward Block", "No Reward Block")))

cat("\n\n#### Overall\n\n")

cycle_rt_overall <- cycle_rt_summary |>
  group_by(BlockType, rewarded_this_cycle, Congruency) |>
  summarise(
    means = round(mean(mean_rt, na.rm = TRUE)),
    sd = round(sd(mean_rt, na.rm = TRUE)),
    n = n(),
    .groups = "drop"
    ) |>
  mutate(se = round(sd/sqrt(n)))

print(
  cycle_rt_overall |>
    rename(
      "Block Type" = BlockType,
      "Color Rewarded (cycle)" = rewarded_this_cycle,
      "Mean RT (ms)" = means,
      "SD" = sd,
      "N" = n
      ) |>
    knitr::kable(
      format = "markdown",
      digits = 0) |>
    kableExtra::kable_styling(full_width = FALSE, position = "left")
)
cat("<br>")

p <- ggplot(cycle_rt_overall, aes(x=Congruency, y=means,
             group=rewarded_this_cycle,
             color=rewarded_this_cycle,
             shape=rewarded_this_cycle)) +
  geom_point(size=3)+
  geom_line(size=1) +
  geom_errorbar(aes(ymin=means-se, ymax=means+se), width=.1) +
  geom_text(aes(label=means, 
                hjust=ifelse(Congruency=="Congruent", 1.5, -0.5)),
          size=4,
          color = "black",
          show.legend=FALSE) +
  xlab("Trial Type") +
  ylab("Reaction Time (ms)") +
  ylim(c(440, 810)) +
  facet_wrap(~BlockType) +
  scale_color_manual(
    values = c("Yes" = "turquoise3", "No" = "darkgrey")
  ) +
  labs(color = "Color Rewarded (cycle)", shape = "Color Rewarded (cycle)") +
  theme_classic() +
  theme(axis.title.x = element_text(size=15),
        axis.title.y = element_text(size=15),
        axis.text.x = element_text(size = 15, color = "black"),
        axis.text.y = element_text(size = 15, color = "black"),
        legend.title = element_text(size=14),
        legend.text = element_text(size=14),
        legend.position = c(0.85, 0.25),
        legend.background = element_blank(),
        strip.background = element_blank(),
        strip.text = element_text(size = 15),
        panel.border = element_rect(color = "black", fill = NA))

ggsave(
  filename = "rewarded_cycle.svg", 
  plot = p,
  device = "svg",
  width = 8,  
  height = 5,  
  dpi = 300,   
  bg = "white" 
)

rm(p) # clearing space
```

![](rewarded_cycle.svg){.lightbox style="margin-left: 0;"}

::: {.callout-note collapse="true" appearance="minimal"}
#### Participant-specific averages

```{r}
#| results: asis
#| echo: false
#| warnings: false
#| label: participant-color-reward-means



for (id in unique_sids) {
  
  cat("<br>")
  cat(id)
  print(
    cycle_rt_summary |>
      filter(ShortID == id) |>
      select(-ShortID) |>
      knitr::kable(
        format = "markdown",
        digits = 0
      ) |>
      kableExtra::kable_styling(full_width = FALSE, position = "left")

  )
}

```
:::

<br>

### Distractor Identity Rewarded (across cycle) x Reward Block x Congruency: RT

```{r}
#| results: asis
#| echo: false
#| warnings: false
#| fig-width: 9
#| fig-height: 6
#| dpi: 300
#| fig-format: "svg"
#| fig-retina: 2
#| label: overall-distractor-identity-reward-means

d_cycle_rt_summary <- data |>
  filter(!is.na(AlternatingBlocks) & Stimulus.ACC == 1) |>
  droplevels() |>
  group_by(ShortID, BlockType, rewarded_distractor_identity, Congruency) |>
  summarise(
    mean_rt = round(mean(Stimulus.RT, na.rm = TRUE)),
    sd_rt = round(sd(Stimulus.RT, na.rm = TRUE)),
    n = n(), 
    .groups = "drop"
  ) |>
  mutate(BlockType = factor(BlockType, 
                           levels = c("RewardList", "NoRewardList"),
                           labels = c("Reward Block", "No Reward Block")))

cat("\n\n#### Overall\n\n")

d_cycle_rt_overall <- d_cycle_rt_summary |>
  group_by(BlockType, rewarded_distractor_identity, Congruency) |>
  summarise(
    means = round(mean(mean_rt, na.rm = TRUE)),
    sd = round(sd(mean_rt, na.rm = TRUE)),
    n = n(),
    .groups = "drop"
    ) |>
  mutate(se = round(sd/sqrt(n)))

print(
  d_cycle_rt_overall |>
    rename(
      "Block Type" = BlockType,
      "Distractor Identity Rewarded (cycle)" = rewarded_distractor_identity,
      "Mean RT (ms)" = means,
      "SD" = sd,
      "N" = n
      ) |>
    knitr::kable(
      format = "markdown",
      digits = 0) |>
    kableExtra::kable_styling(full_width = FALSE, position = "left")
)

cat("<br>")

p <- ggplot(d_cycle_rt_overall, aes(x=Congruency, y=means,
             group=rewarded_distractor_identity,
             color=rewarded_distractor_identity,
             shape=rewarded_distractor_identity)) +
  geom_point(size=3)+
  geom_line(size=1, linetype=2) +
  geom_errorbar(aes(ymin=means-se, ymax=means+se), width=.1) +
  geom_text(aes(label=means, 
                hjust=ifelse(Congruency=="Congruent", 1.5, -0.5)),
          size=4,
          color = "black",
          show.legend=FALSE) +
  xlab("Trial Type") +
  ylab("Reaction Time (ms)") +
  ylim(c(440, 810)) +
  facet_wrap(~BlockType) +
  scale_color_manual(
    values = c("Yes" = "turquoise3", "No" = "darkgrey")
  ) +
  labs(color = "Distractor Identity Rewarded (cycle)", shape = "Distractor Identity Rewarded (cycle)") +
  theme_classic() +
  theme(axis.title.x = element_text(size=15),
        axis.title.y = element_text(size=15),
        axis.text.x = element_text(size = 15, color = "black"),
        axis.text.y = element_text(size = 15, color = "black"),
        legend.title = element_text(size=14),
        legend.text = element_text(size=14),
        legend.position = c(0.77, 0.25),
        legend.background = element_blank(),
        strip.background = element_blank(),
        strip.text = element_text(size = 15),
        panel.border = element_rect(color = "black", fill = NA))

ggsave(
  filename = "distractor_rewarded_cycle.svg", 
  plot = p,
  device = "svg",
  width = 8,  
  height = 5,  
  dpi = 300,   
  bg = "white" 
)
rm(p) # clearing space
```

![](distractor_rewarded_cycle.svg){.lightbox style="margin-left: 0;"}

::: {.callout-note collapse="true" appearance="minimal"}
#### Participant-specific averages

```{r}
#| results: asis
#| echo: false
#| warnings: false
#| label: participant-distractor-identity-reward-means



for (id in unique_sids) {
  
  cat("<br>")
  cat(id)
  print(
    d_cycle_rt_summary |>
      filter(ShortID == id) |>
      select(-ShortID) |>
      knitr::kable(
        format = "markdown",
        digits = 0
      ) |>
      kableExtra::kable_styling(full_width = FALSE, position = "left")

  )
  
}

```
:::

<br>

### Trial Series: RT and Stroop

#### Color Item that was rewarded or previously rewarded in the last reward block

<br>

```{r}
#| code-fold: true
#| label: reward-color-series
#| fig-width: 30  # Increased width
#| fig-height: 6  # Increased height
#| dpi: 300
#| fig-format: "svg"
#| fig-retina: 2
#| fig-scroll: true  # Enable horizontal scrolling
#| fig-align: "left"  # Align to left for better scrolling


rtc_series_summary <- data |>
  filter(!is.na(AlternatingBlocks) & Stimulus.ACC==1 & !is.na(rtc_trialnum)) |>
  droplevels() |>
  group_by(ShortID) |>
  mutate(scaled_rt = scale(Stimulus.RT)) |>
  ungroup() |>
  group_by(Congruency, rtc_trialnum) |>
  summarise(
    mean = round(mean(scaled_rt, na.rm = TRUE), 3),
    sd = round(sd(scaled_rt, na.rm = TRUE), 3),
    n = n(), 
    .groups = "drop"
  ) |>
  mutate(se = round(sd/sqrt(n), 3))

shade_regions <- data.frame(
  xmin = c(1, 36.51, 54.51, 90.51, 108.51, 144.51, 162.51, 198.51),
  xmax = c(36.49, 54.49, 90.49, 108.49, 144.49, 162.49, 198.49, 216),
  fill = c("paleturquoise1", "grey", "paleturquoise1", "grey",
           "paleturquoise1", "grey", "paleturquoise1", "grey")
)

p <- ggplot(data = rtc_series_summary,
            aes(x = rtc_trialnum, y = mean,
                color = Congruency, group = Congruency)) +
  geom_rect(data = shade_regions,
            aes(xmin = xmin, xmax = xmax,
                ymin = -Inf, ymax = Inf,
                fill = fill),
            inherit.aes = FALSE,
            alpha = 0.2) +
  scale_fill_identity() +  # Use the fill colors as specified
  geom_point(size = 3) +
  geom_line(size = 1) +
  geom_errorbar(aes(ymin = mean - se, 
                    ymax = mean + se),
                width = 0.2) +
  scale_color_manual(values = c("Congruent" = "lightgreen",
                               "Incongruent" = "lightcoral")) +
  scale_x_continuous(breaks = seq(0, max(rtc_series_summary$rtc_trialnum),
                                  by = 5), expand = c(0,0)) +
  labs(x = "Rewarded Trial Number",
       y = "Reaction Time (scaled)",
       title = "RT Series for only Rewarded Colors by Congruency") +
  ylim(c(-2.5, 2.5)) +
  theme_classic() +
  theme(axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        legend.title = element_text(size = 18),
        legend.text = element_text(size = 16),
        legend.background = element_blank(),
        legend.key = element_blank(),
        legend.position = c(.96, .15),
        plot.title = element_text(size = 28))

ggsave(
  filename = "rewarded_color_series.svg", 
  plot = p,
  device = "svg",
  width = 30,  
  height = 6,  
  dpi = 300,   
  bg = "white" 
)

rm(p) # clearing space
```

![Note. We z-scored within participants since, for a given trial, a participant can only encounter either a congurent stimulus *or* an incongruent stimulus. Because trial order effects may vary based on general processing speed RT, scaling allows for a more representative trial series when collapsing across partcipants.](rewarded_color_series.svg){.lightbox}

<br>

```{r}
#| code-fold: true
#| label: reward-color-stroop-series
#| fig-width: 30  # Increased width
#| fig-height: 6  # Increased height
#| dpi: 300
#| fig-format: "svg"
#| fig-retina: 2
#| fig-scroll: true  # Enable horizontal scrolling
#| fig-align: "left"  # Align to left for better scrolling

rtc_stroop_summary <- data |>
  filter(!is.na(AlternatingBlocks) & Stimulus.ACC==1 & !is.na(rtc_trialnum)) |>
  droplevels() |>
  group_by(ShortID) |>
  mutate(scaled_rt = scale(Stimulus.RT)) |>
  ungroup() |>
  group_by(Congruency, rtc_trialnum)|>
  summarise(
    mean_rt = round(mean(scaled_rt, na.rm=TRUE), 3),
    .groups = "drop"
  ) |>
  pivot_wider(
    id_cols = rtc_trialnum,
    names_from = Congruency,
    values_from = mean_rt
  ) |>
  mutate(stroop_scaled = Incongruent - Congruent)

p <- ggplot(data = rtc_stroop_summary, aes(x = rtc_trialnum, y = stroop_scaled)) +
  geom_rect(data = shade_regions,
            aes(xmin = xmin, xmax = xmax,
                ymin = -Inf, ymax = Inf,
                fill = fill),
            inherit.aes = FALSE,
            alpha = 0.2) +
  scale_fill_identity() +  # Use the fill colors as specified
  geom_point(size = 3) +
  geom_line(size = 1) +
  geom_hline(yintercept=0, linetype=2, size=1, color = "tomato3") +
  scale_x_continuous(breaks = seq(0, max(rtc_stroop_summary$rtc_trialnum),
                                  by = 5), expand = c(0,0)) +
  labs(x = "Rewarded Trial Number",
       y = "Stroop (scaled)",
       title = "Stroop Series for only Rewarded Colors") +
  ylim(c(-2.5, 2.5)) +
  theme_classic() +
  theme(axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        plot.title = element_text(size = 28))

ggsave(
  filename = "stroop_series.svg", 
  plot = p,
  device = "svg",
  width = 30,  
  height = 6,  
  dpi = 300,   
  bg = "white" 
)

rm(p)
```

![Note. We take the difference between incongruent and congruent z-scored RTs. A within-participant difference at a given trial cannot be computed due to the reason noted in the raw RT series. As such the "Stroop" effect here is a between-participant difference at each trial. Values above the the dashed line indicate a (positive) "Stroop" effect. Values below the dashed line indicate a reverse (negative) "Stroop" effect.](stroop_series.svg){.lightbox}

------------------------------------------------------------------------

<br>

## Response Key Summaries

:::: {.callout-note collapse="true" appearance="minimal"}
### Mean RT by key pressed

::: panel-tabset
#### Overall

```{r}
#| results: asis
#| echo: false
#| label: overall-response-key-means

response_digit_df <- data |>
  filter(!is.na(AlternatingBlocks) & Stimulus.ACC == 1) |>
  droplevels() |>
  group_by(ShortID, Stimulus.RESP) |>
  summarise(
    mean_rt = mean(Stimulus.RT, na.rm = TRUE),
    sd = sd(Stimulus.RT, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )


print(
  response_digit_df |>
    group_by(Stimulus.RESP) |>
    summarise(
      means = round(mean(mean_rt, na.rm = TRUE)),
      sd = sd(mean_rt, na.rm = TRUE),
      n = n(),
      .groups = "drop"
      ) |>
    knitr::kable(
      format = "markdown",
      digits = 0
      ) |>
    kableExtra::kable_styling(full_width = FALSE, position = "left")
)
```

#### Participant-specific

```{r}
#| results: asis
#| echo: false
#| label: participant-response-key-means

for (id in unique_sids) {
  con_cutoff = cutoff_rts$rt_value[cutoff_rts$ShortID==id &
                                     cutoff_rts$cutoff_type=="cutoff_cong"]
  inc_cutoff = cutoff_rts$rt_value[cutoff_rts$ShortID==id &
                                     cutoff_rts$cutoff_type=="cutoff_incong"]
  cat("<br>")
  cat("\n",id,"\n")
  cat("<br>")
  print(
    response_digit_df |>
      filter(ShortID == id) |>
      select(-ShortID) |>
      knitr::kable(
        format = "markdown",
        digits = 0
      ) |>
      kableExtra::kable_styling(full_width = FALSE, position = "left")
    
  )
  cat("Note. Congruent trial RT cutoff = ", con_cutoff,
      " Incongruent trial RT cutoff = ", inc_cutoff, ".")
  cat("<br>")
  cat("\n<br>")
}

  
```
:::
::::
